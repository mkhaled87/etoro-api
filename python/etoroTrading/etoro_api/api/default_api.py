# coding: utf-8

"""
    eToro Trading API

    The Trading API allows the development of the full trading capabilities in the eToro platform  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from etoro_api.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_exit_order(self, system, **kwargs):  # noqa: E501
        """Exit Order<span> </span>  # noqa: E501

        The Create Exit Order, will create an exit order in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_exit_order(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param object body: The following is the structure of the body request

<div class="panel">
<div class="row panel-body">
<div class="col-md-3"><label>PositionId</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The position which I would like to close</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>ExecutionType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The execution mode of the exit order. It can be either 'IOC' for immediate or cancel, or 'GTC' for good till cancelled</div>
</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>Units</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">(Optional) Number of units to close</div>
</div>
</div>

        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_exit_order_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.create_exit_order_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def create_exit_order_with_http_info(self, system, **kwargs):  # noqa: E501
        """Exit Order<span> </span>  # noqa: E501

        The Create Exit Order, will create an exit order in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_exit_order_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param object body: The following is the structure of the body request

<div class="panel">
<div class="row panel-body">
<div class="col-md-3"><label>PositionId</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The position which I would like to close</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>ExecutionType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The execution mode of the exit order. It can be either 'IOC' for immediate or cancel, or 'GTC' for good till cancelled</div>
</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>Units</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">(Optional) Number of units to close</div>
</div>
</div>

        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_exit_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `create_exit_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/ExitOrder/{System}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_exit_order(self, system, order_id, **kwargs):  # noqa: E501
        """Exit Order<span></span>  # noqa: E501

        The Delete Exit Order, will delete an existing exit order from the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_exit_order(system, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param float order_id: The exit order id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_exit_order_with_http_info(system, order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_exit_order_with_http_info(system, order_id, **kwargs)  # noqa: E501
            return data

    def delete_exit_order_with_http_info(self, system, order_id, **kwargs):  # noqa: E501
        """Exit Order<span></span>  # noqa: E501

        The Delete Exit Order, will delete an existing exit order from the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_exit_order_with_http_info(system, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param float order_id: The exit order id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_exit_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `delete_exit_order`")  # noqa: E501
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `delete_exit_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501
        if 'order_id' in params:
            path_params['OrderId'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/ExitOrder/{System}/{OrderId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_order(self, system, order_id, **kwargs):  # noqa: E501
        """Entry Order<span></span>  # noqa: E501

        The Delete Entry Order allows cancellation of an entry order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order(system, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param float order_id: The order id which we would like to delete (required)
        :param object body: The body defines which order type to delete

<div class="panel">
<div class="row panel-body">
<div class="col-md-3"><label>OrderType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The order type can be either 'MKT' for market orders or 'LMT' for limit orders</div>
</div>

</div>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_order_with_http_info(system, order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_order_with_http_info(system, order_id, **kwargs)  # noqa: E501
            return data

    def delete_order_with_http_info(self, system, order_id, **kwargs):  # noqa: E501
        """Entry Order<span></span>  # noqa: E501

        The Delete Entry Order allows cancellation of an entry order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order_with_http_info(system, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param float order_id: The order id which we would like to delete (required)
        :param object body: The body defines which order type to delete

<div class="panel">
<div class="row panel-body">
<div class="col-md-3"><label>OrderType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The order type can be either 'MKT' for market orders or 'LMT' for limit orders</div>
</div>

</div>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'order_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `delete_order`")  # noqa: E501
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `delete_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501
        if 'order_id' in params:
            path_params['OrderId'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/EntryOrder/{System}/{OrderId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def do_login(self, **kwargs):  # noqa: E501
        """Account  # noqa: E501

        <br> The account login method provides the ability to login to the eToro system. <br><br> This operation is essential as it provides the credentials that are needed for subsequent API calls. The username and password are related to an account <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_login(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.do_login_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.do_login_with_http_info(**kwargs)  # noqa: E501
            return data

    def do_login_with_http_info(self, **kwargs):  # noqa: E501
        """Account  # noqa: E501

        <br> The account login method provides the ability to login to the eToro system. <br><br> This operation is essential as it provides the credentials that are needed for subsequent API calls. The username and password are related to an account <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_login_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method do_login" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Account/Login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def do_logout(self, **kwargs):  # noqa: E501
        """Account<span></span>    # noqa: E501

        <br> The DELETE operation will perform a logoff from the account. <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_logout(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str subscription_key: subscription key in url
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.do_logout_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.do_logout_with_http_info(**kwargs)  # noqa: E501
            return data

    def do_logout_with_http_info(self, **kwargs):  # noqa: E501
        """Account<span></span>    # noqa: E501

        <br> The DELETE operation will perform a logoff from the account. <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_logout_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str subscription_key: subscription key in url
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method do_logout" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'subscription_key' in params:
            query_params.append(('subscription-key', params['subscription_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Account/Login', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_position(self, system, position_id, **kwargs):  # noqa: E501
        """Trade<span></span>  # noqa: E501

        Editing the trade allows changing the stop loss (rate + trailing property) and the stop loss  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_position(system, position_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system which we will be using (required)
        :param float position_id: The position ID which we would like to modify (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_position_with_http_info(system, position_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_position_with_http_info(system, position_id, **kwargs)  # noqa: E501
            return data

    def edit_position_with_http_info(self, system, position_id, **kwargs):  # noqa: E501
        """Trade<span></span>  # noqa: E501

        Editing the trade allows changing the stop loss (rate + trailing property) and the stop loss  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_position_with_http_info(system, position_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system which we will be using (required)
        :param float position_id: The position ID which we would like to modify (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'position_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_position" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `edit_position`")  # noqa: E501
        # verify the required parameter 'position_id' is set
        if ('position_id' not in params or
                params['position_id'] is None):
            raise ValueError("Missing the required parameter `position_id` when calling `edit_position`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501
        if 'position_id' in params:
            path_params['PositionId'] = params['position_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Trade/{System}/{PositionId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit(self, system, **kwargs):  # noqa: E501
        """Credit  # noqa: E501

        The Credit method returns the current credit in the user account <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_credit_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.get_credit_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def get_credit_with_http_info(self, system, **kwargs):  # noqa: E501
        """Credit  # noqa: E501

        The Credit method returns the current credit in the user account <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_credit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Credit/{System}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_equity(self, system, **kwargs):  # noqa: E501
        """Equity  # noqa: E501

        The Equity method returns the current equity in the user account <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_equity(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_equity_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.get_equity_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def get_equity_with_http_info(self, system, **kwargs):  # noqa: E501
        """Equity  # noqa: E501

        The Equity method returns the current equity in the user account <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_equity_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_equity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_equity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Equity/{System}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_equity_history(self, system, period, min_date, max_date, username, **kwargs):  # noqa: E501
        """Equity History  # noqa: E501

        The Historic equity method returns a time-series of the periodic equity of a user <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_equity_history(system, period, min_date, max_date, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param str period: The Requested Period (required)
        :param str min_date: Minimum Date (required)
        :param str max_date: Maximum Date (required)
        :param str username: The requested username (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_equity_history_with_http_info(system, period, min_date, max_date, username, **kwargs)  # noqa: E501
        else:
            (data) = self.get_equity_history_with_http_info(system, period, min_date, max_date, username, **kwargs)  # noqa: E501
            return data

    def get_equity_history_with_http_info(self, system, period, min_date, max_date, username, **kwargs):  # noqa: E501
        """Equity History  # noqa: E501

        The Historic equity method returns a time-series of the periodic equity of a user <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_equity_history_with_http_info(system, period, min_date, max_date, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param str period: The Requested Period (required)
        :param str min_date: Minimum Date (required)
        :param str max_date: Maximum Date (required)
        :param str username: The requested username (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'period', 'min_date', 'max_date', 'username']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_equity_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_equity_history`")  # noqa: E501
        # verify the required parameter 'period' is set
        if ('period' not in params or
                params['period'] is None):
            raise ValueError("Missing the required parameter `period` when calling `get_equity_history`")  # noqa: E501
        # verify the required parameter 'min_date' is set
        if ('min_date' not in params or
                params['min_date'] is None):
            raise ValueError("Missing the required parameter `min_date` when calling `get_equity_history`")  # noqa: E501
        # verify the required parameter 'max_date' is set
        if ('max_date' not in params or
                params['max_date'] is None):
            raise ValueError("Missing the required parameter `max_date` when calling `get_equity_history`")  # noqa: E501
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `get_equity_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501
        if 'period' in params:
            path_params['Period'] = params['period']  # noqa: E501

        query_params = []
        if 'min_date' in params:
            query_params.append(('MinDate', params['min_date']))  # noqa: E501
        if 'max_date' in params:
            query_params.append(('MaxDate', params['max_date']))  # noqa: E501
        if 'username' in params:
            query_params.append(('Username', params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Equity/{System}/History/{Period}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_exit_orders(self, system, **kwargs):  # noqa: E501
        """Exit Order  # noqa: E501

        The Order returns all the open exit orders in the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exit_orders(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_exit_orders_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.get_exit_orders_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def get_exit_orders_with_http_info(self, system, **kwargs):  # noqa: E501
        """Exit Order  # noqa: E501

        The Order returns all the open exit orders in the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exit_orders_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_exit_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_exit_orders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/ExitOrder/{System}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fees(self, system, **kwargs):  # noqa: E501
        """Fees  # noqa: E501

        The Instruments fees returns the rollover fees that are charged in the system  <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fees(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The trading system.  (required)
        :param str instrument_ids: Optional list of instrument ids. The list should be comma delimited
        :param str ocp_apim_subscription_key: subscription key in header
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_fees_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fees_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def get_fees_with_http_info(self, system, **kwargs):  # noqa: E501
        """Fees  # noqa: E501

        The Instruments fees returns the rollover fees that are charged in the system  <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fees_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The trading system.  (required)
        :param str instrument_ids: Optional list of instrument ids. The list should be comma delimited
        :param str ocp_apim_subscription_key: subscription key in header
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'instrument_ids', 'ocp_apim_subscription_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fees" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_fees`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []
        if 'instrument_ids' in params:
            query_params.append(('InstrumentIds', params['instrument_ids']))  # noqa: E501

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Fees/{System}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_instrument_metadata(self, system, **kwargs):  # noqa: E501
        """Metadata  # noqa: E501

        The Instruments metadata returns the trading metadata on assets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instrument_metadata(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The trading system.  (required)
        :param str instrument_ids: Optional list of instrument ids. The list should be comma delimited
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_instrument_metadata_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.get_instrument_metadata_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def get_instrument_metadata_with_http_info(self, system, **kwargs):  # noqa: E501
        """Metadata  # noqa: E501

        The Instruments metadata returns the trading metadata on assets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instrument_metadata_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The trading system.  (required)
        :param str instrument_ids: Optional list of instrument ids. The list should be comma delimited
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'instrument_ids', 'subscription_key', 'ocp_apim_subscription_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_instrument_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_instrument_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []
        if 'instrument_ids' in params:
            query_params.append(('InstrumentIds', params['instrument_ids']))  # noqa: E501
        if 'subscription_key' in params:
            query_params.append(('subscription-key', params['subscription_key']))  # noqa: E501

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Metadata/{System}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_orders(self, system, **kwargs):  # noqa: E501
        """Entry Order  # noqa: E501

        The Order returns all the open orders in the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_orders_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.get_orders_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def get_orders_with_http_info(self, system, **kwargs):  # noqa: E501
        """Entry Order  # noqa: E501

        The Order returns all the open orders in the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_orders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/EntryOrder/{System}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_trade_history(self, system, min_date, page, page_size, **kwargs):  # noqa: E501
        """Trade History  # noqa: E501

        The Trade History method returns closed trades of the user according to the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trade_history(system, min_date, page, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param str min_date: Minimum date for the historic trades (required)
        :param int page: Requested Page (required)
        :param int page_size: The number of values per pages which should be returned (required)
        :param str ocp_apim_subscription_key: subscription key in header
        :param str x_token_: Security Token from Login Operation
        :param str x_csrf_token: Security Token from Login Operation
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_trade_history_with_http_info(system, min_date, page, page_size, **kwargs)  # noqa: E501
        else:
            (data) = self.get_trade_history_with_http_info(system, min_date, page, page_size, **kwargs)  # noqa: E501
            return data

    def get_trade_history_with_http_info(self, system, min_date, page, page_size, **kwargs):  # noqa: E501
        """Trade History  # noqa: E501

        The Trade History method returns closed trades of the user according to the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trade_history_with_http_info(system, min_date, page, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param str min_date: Minimum date for the historic trades (required)
        :param int page: Requested Page (required)
        :param int page_size: The number of values per pages which should be returned (required)
        :param str ocp_apim_subscription_key: subscription key in header
        :param str x_token_: Security Token from Login Operation
        :param str x_csrf_token: Security Token from Login Operation
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'min_date', 'page', 'page_size', 'ocp_apim_subscription_key', 'x_token_', 'x_csrf_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trade_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_trade_history`")  # noqa: E501
        # verify the required parameter 'min_date' is set
        if ('min_date' not in params or
                params['min_date'] is None):
            raise ValueError("Missing the required parameter `min_date` when calling `get_trade_history`")  # noqa: E501
        # verify the required parameter 'page' is set
        if ('page' not in params or
                params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `get_trade_history`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if ('page_size' not in params or
                params['page_size'] is None):
            raise ValueError("Missing the required parameter `page_size` when calling `get_trade_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []
        if 'min_date' in params:
            query_params.append(('MinDate', params['min_date']))  # noqa: E501
        if 'page' in params:
            query_params.append(('Page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('PageSize', params['page_size']))  # noqa: E501

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']  # noqa: E501
        if 'x_token_' in params:
            header_params['x-token '] = params['x_token_']  # noqa: E501
        if 'x_csrf_token' in params:
            header_params['x-csrf-token'] = params['x_csrf_token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Trade/{System}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_trades(self, system, **kwargs):  # noqa: E501
        """Trade  # noqa: E501

        The Trade method returns the open trades of the user according to the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trades(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_trades_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.get_trades_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def get_trades_with_http_info(self, system, **kwargs):  # noqa: E501
        """Trade  # noqa: E501

        The Trade method returns the open trades of the user according to the system <br><br> It is important to note that the values of <span class=\"emph\">x-token</span> and <span class=\"emph\">x-csrf-token</span> must be sent as headers to this request. These values were returned from the <a href=\"https://api-portal.etoro.com/docs/services/58982f8b7dfd940ef4e0157d/operations/589831007dfd940ef4e0157e\">Account/Login <span class=\"badge badge-warning\">POST</span></a> command <br><br>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_trades_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param str subscription_key: subscription key in url
        :param str ocp_apim_subscription_key: subscription key in header
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'subscription_key', 'ocp_apim_subscription_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trades" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `get_trades`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []
        if 'subscription_key' in params:
            query_params.append(('subscription-key', params['subscription_key']))  # noqa: E501

        header_params = {}
        if 'ocp_apim_subscription_key' in params:
            header_params['Ocp-Apim-Subscription-Key'] = params['ocp_apim_subscription_key']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/Trade/{System}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def place_order(self, system, **kwargs):  # noqa: E501
        """Entry Order<span> </span>  # noqa: E501

        The Add Entry Order allows creation of an entry order in the system. There are several types of orders which are available and are defined using the OrderType and ExecutionType parameters. <br><br> The OrderType parameter may be either Market (abbreviated by MKT) or Limit (abbreviated by LMT). <br><br> The ExecutionType can be either Good Till Cancelled (abbreviated by GTC) or Immediate or Cancel (abbreviated by IOC)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_order(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param object body: The body defines the actual order

<div class="panel">
<div class="row panel-body">
<div class="col-md-3"><label>InstrumentID</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The Instrument ID on which the order references</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>IsBuy</label></div>
<div class="col-md-1">boolean</div>
<div class="col-md-8">Is the opened position on the buy or sell side</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>Leverage</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The requested leverage</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>Investment</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The invested amount for the order</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>Units</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The number of units to buy (either this or the investment are mandatory)</div>
</div>


<div class="row panel-body">
<div class="col-md-3"><label>OrderType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The order type can be either 'MKT' for market orders or 'LMT' for limit orders</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>ExecutionType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The execution type can be either 'GTC' for good till cancel orders, or 'IOC' for immediate of cancel orders</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>StopLossRate</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The stop loss rate for the position. This property is mandatory for limit orders and market orders which are immediate or cancel</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>TakeProfitRate</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The take profit rate for the position. This property is mandatory for limit orders and market orders which are immediate or cancel</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>StopLossPct</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The stop loss percentage for the position. This is mandatory for market orders which are good till cancelled MKT/GTC</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>TakeProfitPct</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The take profit percentage for the position. This is mandatory for market orders which are good till cancelled MKT/GTC</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>LimitRate</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The limit rate. This is relevant for limit orders LMT/GTC</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>IsTrailingStopLoss</label></div>
<div class="col-md-1">boolean</div>
<div class="col-md-8">Should the trade be opened with a trailing stop loss</div>
</div>

</div>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.place_order_with_http_info(system, **kwargs)  # noqa: E501
        else:
            (data) = self.place_order_with_http_info(system, **kwargs)  # noqa: E501
            return data

    def place_order_with_http_info(self, system, **kwargs):  # noqa: E501
        """Entry Order<span> </span>  # noqa: E501

        The Add Entry Order allows creation of an entry order in the system. There are several types of orders which are available and are defined using the OrderType and ExecutionType parameters. <br><br> The OrderType parameter may be either Market (abbreviated by MKT) or Limit (abbreviated by LMT). <br><br> The ExecutionType can be either Good Till Cancelled (abbreviated by GTC) or Immediate or Cancel (abbreviated by IOC)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.place_order_with_http_info(system, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str system: The system type where the data is requested from (required)
        :param object body: The body defines the actual order

<div class="panel">
<div class="row panel-body">
<div class="col-md-3"><label>InstrumentID</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The Instrument ID on which the order references</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>IsBuy</label></div>
<div class="col-md-1">boolean</div>
<div class="col-md-8">Is the opened position on the buy or sell side</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>Leverage</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The requested leverage</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>Investment</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The invested amount for the order</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>Units</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The number of units to buy (either this or the investment are mandatory)</div>
</div>


<div class="row panel-body">
<div class="col-md-3"><label>OrderType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The order type can be either 'MKT' for market orders or 'LMT' for limit orders</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>ExecutionType</label></div>
<div class="col-md-1">string</div>
<div class="col-md-8">The execution type can be either 'GTC' for good till cancel orders, or 'IOC' for immediate of cancel orders</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>StopLossRate</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The stop loss rate for the position. This property is mandatory for limit orders and market orders which are immediate or cancel</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>TakeProfitRate</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The take profit rate for the position. This property is mandatory for limit orders and market orders which are immediate or cancel</div>
</div>

<div class="row panel-body">
<div class="col-md-3"><label>StopLossPct</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The stop loss percentage for the position. This is mandatory for market orders which are good till cancelled MKT/GTC</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>TakeProfitPct</label><span class="text-muted">(optional)</span></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The take profit percentage for the position. This is mandatory for market orders which are good till cancelled MKT/GTC</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>LimitRate</label></div>
<div class="col-md-1">number</div>
<div class="col-md-8">The limit rate. This is relevant for limit orders LMT/GTC</div>
</div>
<div class="row panel-body">
<div class="col-md-3"><label>IsTrailingStopLoss</label></div>
<div class="col-md-1">boolean</div>
<div class="col-md-8">Should the trade be opened with a trailing stop loss</div>
</div>

</div>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system' is set
        if ('system' not in params or
                params['system'] is None):
            raise ValueError("Missing the required parameter `system` when calling `place_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system' in params:
            path_params['System'] = params['system']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyHeader', 'apiKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/EntryOrder/{System}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
